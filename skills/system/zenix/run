#!/bin/bash
#
# zenix - Unified CLI dispatcher for zenix skills
#
# Usage:
#   zenix                    List available skills
#   zenix list               Same as above
#   zenix <skill> [args]     Run a skill
#   zenix create <name>      Create new skill in custom/
#   zenix convert <path>     Convert skill to git submodule
#   zenix doctor [name]      Validate skill conventions
#   zenix setup [cmd]        Install dependencies (delegates to scripts/setup.sh)
#

set -euo pipefail

SKILLS_DIR="$ZENIX_ROOT/skills"
DATA_ROOT="$ZENIX_ROOT/data"
ZENIX_DIR="$SKILLS_DIR/system/zenix"

source "$ZENIX_DIR/lib/output.sh"

# ─────────────────────────────────────────────────────────────
# list - show available skills (with optional filtering)
#
# Usage:
#   zenix list                  # all skills
#   zenix list system           # category filter
#   zenix list work browser     # individual skills
#   zenix list --inline         # flat list
# ─────────────────────────────────────────────────────────────
cmd_list() {
    local style="--group"
    local filters=()

    # Parse args
    for arg in "$@"; do
        case "$arg" in
            --inline) style="--inline" ;;
            --group)  style="--group" ;;
            *)        filters+=("$arg") ;;
        esac
    done

    # Generate TSV and pipe to formatter
    {
        for skill_md in "$SKILLS_DIR"/*/*/SKILL.md; do
            [[ -f "$skill_md" ]] || continue

            local skill_dir=$(dirname "$skill_md")
            local name=$(basename "$skill_dir")
            local category=$(basename "$(dirname "$skill_dir")")

            # Apply filter (match category or skill name)
            if [[ ${#filters[@]} -gt 0 ]]; then
                local match=false
                for f in "${filters[@]}"; do
                    [[ "$category" == "$f" || "$name" == "$f" ]] && match=true
                done
                $match || continue
            fi

            # Parse description
            local desc=$(grep "^description:" "$skill_md" 2>/dev/null | sed 's/description:[[:space:]]*//' | head -1)
            [[ -z "$desc" ]] && desc="(no description)"

            # Tag: info only if no run script
            local tag=""
            [[ ! -x "$skill_dir/run" ]] && tag="info only"

            # TSV: category, name, tag, description
            printf '%s\t%s\t%s\t%s\n' "$category" "$name" "$tag" "$desc"
        done
    } | "$ZENIX_DIR/lib/list-format.sh" "$style"

    # Footer only if no filters (interactive use)
    if [[ ${#filters[@]} -eq 0 && "$style" == "--group" ]]; then
        echo ""
        echo -e "${DIM}Use \`zenix <skill>\` to run a skill.${NC}"
    fi
}

# ─────────────────────────────────────────────────────────────
# create - create new skill with full scaffold (always in custom/)
# ─────────────────────────────────────────────────────────────
cmd_create() {
    local name="$1"

    if [[ -z "$name" ]]; then
        echo "Usage: zenix create <name>"
        exit 1
    fi

    # Reserved names
    case "$name" in
        list|create|convert|doctor|help|-h|--help)
            err "Cannot create skill with reserved name: $name"
            exit 1
            ;;
    esac

    # Always create in custom/ category
    local category="custom"
    mkdir -p "$SKILLS_DIR/$category"

    local skill_dir="$SKILLS_DIR/$category/$name"
    local data_dir="$DATA_ROOT/$name"

    if [[ -d "$skill_dir" ]]; then
        err "Skill already exists: $skill_dir"
        exit 1
    fi

    echo -e "${BLUE}Creating skill:${NC} $name"

    # Create all directories
    mkdir -p "$skill_dir"/{scripts,prompts,templates,watch,hooks,lib,config}
    ok "Created directories"

    # Create data directory and symlink
    mkdir -p "$data_dir"
    ln -s "$data_dir" "$skill_dir/data"
    ok "Created data symlink → $data_dir"

    # Create SKILL.md
    cat > "$skill_dir/SKILL.md" << EOF
---
name: $name
description: TODO: Add description
---

# $name

TODO: Describe what this skill does.

## Usage

TODO: How to use this skill.
EOF
    ok "Created SKILL.md"

    # Create run
    cat > "$skill_dir/run" << 'EOF'
#!/bin/bash
set -euo pipefail

case "${1:-}" in
    *)
        echo "Usage: $SKILL_NAME <command>"
        echo ""
        echo "Commands:"
        echo "  TODO: Add commands"
        ;;
esac
EOF
    # Replace placeholder with actual skill name
    sed -i '' "s/\$SKILL_NAME/$name/" "$skill_dir/run"
    chmod +x "$skill_dir/run"
    ok "Created run"

    # Create env
    cat > "$skill_dir/env" << 'EOF'
# Uncomment next line to load at shell startup (not just skill invocation)
# @always

# Export skill-specific environment variables here
# export MY_VAR="value"
EOF
    ok "Created env"

    # Create .gitignore
    echo "data" > "$skill_dir/.gitignore"
    ok "Created .gitignore"

    # Create protection.yaml
    cat > "$skill_dir/protection.yaml" << 'EOF'
# Protection settings for this skill/repo
# See: skills/system/work/config/protection.yaml for global settings

# Option A: Make entire repo loose (skip workspace enforcement)
# protection: loose

# Option B: Keep strict, but allow specific paths
protection: strict
loose_paths: []
  # - scripts/**
  # - docs/**
  # - .tmp/**
EOF
    ok "Created protection.yaml"

    echo ""
    echo -e "${GREEN}Skill created:${NC} $skill_dir"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $skill_dir/SKILL.md"
    echo "  2. Edit $skill_dir/run"
    echo "  3. Add env vars to $skill_dir/env (optional)"
    echo "  4. Run: zenix $name"
}

# ─────────────────────────────────────────────────────────────
# doctor - verify skill follows conventions
# ─────────────────────────────────────────────────────────────
cmd_doctor() {
    local name="${1:-}"
    local exit_code=0

    if [[ -n "$name" ]]; then
        # Find skill by name
        local skill_dir=$(find "$SKILLS_DIR" -maxdepth 2 -type d -name "$name" | head -1)
        if [[ -z "$skill_dir" ]]; then
            err "Skill not found: $name"
            return 1
        fi
        check_skill "$skill_dir" || exit_code=1
    else
        # Check all skills
        for skill_md in "$SKILLS_DIR"/*/*/SKILL.md; do
            [[ -f "$skill_md" ]] || continue
            local skill_dir=$(dirname "$skill_md")
            check_skill "$skill_dir" || exit_code=1
            echo ""
        done
    fi

    return $exit_code
}

check_skill() {
    local skill_dir="$1"
    local name=$(basename "$skill_dir")
    local category=$(basename "$(dirname "$skill_dir")")
    local issues=0

    echo -e "${BLUE}[${category}/${name}]${NC}"

    # SKILL.md exists
    if [[ -f "$skill_dir/SKILL.md" ]]; then
        ok "SKILL.md"

        # Has frontmatter with name and description
        if head -1 "$skill_dir/SKILL.md" | grep -q "^---"; then
            if grep -q "^name:" "$skill_dir/SKILL.md" && grep -q "^description:" "$skill_dir/SKILL.md"; then
                ok "frontmatter (name, description)"
            else
                warn "frontmatter missing name or description"
                ((issues++))
            fi
        else
            warn "missing frontmatter"
            ((issues++))
        fi
    else
        err "SKILL.md missing"
        ((issues++))
    fi

    # run is executable (if exists)
    if [[ -f "$skill_dir/run" ]]; then
        if [[ -x "$skill_dir/run" ]]; then
            ok "run executable"
        else
            err "run not executable"
            ((issues++))
        fi
    fi

    # watch/*.yaml have name and type (if any exist)
    if [[ -d "$skill_dir/watch" ]]; then
        for yaml in "$skill_dir/watch"/*.yaml; do
            [[ -f "$yaml" ]] || continue
            local yaml_name=$(basename "$yaml")

            if grep -q "^name:" "$yaml" && grep -q "^type:" "$yaml"; then
                ok "watch/$yaml_name"
            else
                err "watch/$yaml_name missing name or type"
                ((issues++))
            fi
        done
    fi

    # data symlink valid (if exists)
    if [[ -L "$skill_dir/data" ]]; then
        if [[ -d "$skill_dir/data" ]]; then
            ok "data symlink"
        else
            err "data symlink broken"
            ((issues++))
        fi
    fi

    # hooks are executable (if any exist)
    if [[ -d "$skill_dir/hooks" ]]; then
        for hook in "$skill_dir/hooks"/*.sh; do
            [[ -f "$hook" ]] || continue
            local hook_name=$(basename "$hook")

            if [[ -x "$hook" ]]; then
                ok "hooks/$hook_name"
            else
                err "hooks/$hook_name not executable"
                ((issues++))
            fi
        done
    fi

    # Summary
    if [[ $issues -gt 0 ]]; then
        echo -e "  ${RED}$issues issue(s)${NC}"
        return 1
    fi
    return 0
}

# ─────────────────────────────────────────────────────────────
# route - find and execute a skill
# ─────────────────────────────────────────────────────────────
route_skill() {
    local skill_name="$1"
    shift

    # Find skill run script
    local run_script=$(find "$SKILLS_DIR" -maxdepth 3 -path "*/$skill_name/run" 2>/dev/null | head -1)

    if [[ -z "$run_script" ]] || [[ ! -x "$run_script" ]]; then
        # Check if skill exists but has no run script
        local skill_md=$(find "$SKILLS_DIR" -maxdepth 3 -path "*/$skill_name/SKILL.md" 2>/dev/null | head -1)
        if [[ -n "$skill_md" ]]; then
            err "'$skill_name' is info-only (no run script)"
            echo ""
            echo "View documentation:"
            echo "  cat $(dirname "$skill_md")/SKILL.md"
        else
            err "Skill not found: $skill_name"
            echo ""
            echo "Run 'zenix' to see available skills."
        fi
        exit 1
    fi

    # Source skill's env if exists (lazy loading)
    local skill_dir=$(dirname "$run_script")
    local skill_env="$skill_dir/env"
    [[ -f "$skill_env" ]] && source "$skill_env"

    exec "$run_script" "$@"
}

# ─────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────
case "${1:-}" in
    "")
        cmd_list
        ;;
    list)
        shift
        cmd_list "$@"
        ;;
    create)
        cmd_create "${2:-}"
        ;;
    doctor)
        cmd_doctor "${2:-}"
        ;;
    convert)
        shift
        exec "$ZENIX_DIR/scripts/convert.sh" "$@"
        ;;
    setup)
        shift
        exec "$ZENIX_DIR/scripts/setup.sh" "$@"
        ;;
    -h|--help)
        echo "zenix - Unified CLI dispatcher for zenix skills"
        echo ""
        echo "Usage:"
        echo "  zenix                          List all skills"
        echo "  zenix list [filter...]         List skills (filter by category or name)"
        echo "  zenix <skill> [args]           Run a skill"
        echo "  zenix create <name>            Create new skill in custom/"
        echo "  zenix convert <path>           Convert skill to git submodule"
        echo "  zenix doctor [name]            Validate skill conventions"
        echo "  zenix setup [cmd]              Install dependencies (run 'zenix setup help')"
        echo ""
        echo "Examples:"
        echo "  zenix list system              List system category"
        echo "  zenix list work browser        List specific skills"
        echo "  zenix convert core/memory      Convert memory skill to submodule"
        ;;
    *)
        route_skill "$@"
        ;;
esac
