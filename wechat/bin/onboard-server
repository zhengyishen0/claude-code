#!/usr/bin/env python3
"""
Web-based onboarding server for WeChat setup.
Handles QR code display, login detection, and migration image upload.
"""

import http.server
import json
import os
import re
import subprocess
import time
import base64
import io
from pathlib import Path
from urllib.parse import urlparse

try:
    import cv2
    import numpy as np
    import qrcode
    QR_LIBS_AVAILABLE = True
except ImportError:
    QR_LIBS_AVAILABLE = False

PORT = 8765
AVD_NAME = "WeChat_Tablet"
ADB_DEVICE = "emulator-5554"


class UIAutomator:
    """Helper class for UI automation without pixel coordinates."""

    @staticmethod
    def run_adb(*args, timeout=10):
        """Run ADB command and return result."""
        cmd = ["adb", "-s", ADB_DEVICE] + list(args)
        try:
            result = subprocess.run(cmd, capture_output=True, timeout=timeout)
            return result
        except subprocess.TimeoutExpired:
            return None

    @staticmethod
    def dump_ui():
        """Dump UI hierarchy and return XML content."""
        UIAutomator.run_adb("shell", "uiautomator", "dump", "/sdcard/ui.xml")
        result = UIAutomator.run_adb("shell", "cat", "/sdcard/ui.xml")
        if result and result.returncode == 0:
            return result.stdout.decode('utf-8', errors='ignore')
        return ""

    @staticmethod
    def find_element_bounds(ui_xml, text=None, resource_id=None, content_desc=None):
        """
        Find element bounds by text, resource-id, or content-desc.
        Returns (center_x, center_y) or None if not found.
        Works on ANY resolution/orientation.
        """
        patterns = []
        if text:
            # Escape special XML characters
            escaped_text = text.replace("&", "&amp;")
            patterns.append(f'text="{escaped_text}"[^>]*bounds="\\[(\\d+),(\\d+)\\]\\[(\\d+),(\\d+)\\]"')
        if resource_id:
            patterns.append(f'resource-id="{resource_id}"[^>]*bounds="\\[(\\d+),(\\d+)\\]\\[(\\d+),(\\d+)\\]"')
        if content_desc:
            patterns.append(f'content-desc="{content_desc}"[^>]*bounds="\\[(\\d+),(\\d+)\\]\\[(\\d+),(\\d+)\\]"')

        for pattern in patterns:
            match = re.search(pattern, ui_xml)
            if match:
                left, top, right, bottom = map(int, match.groups())
                center_x = (left + right) // 2
                center_y = (top + bottom) // 2
                return (center_x, center_y)
        return None

    @staticmethod
    def click_element(text=None, resource_id=None, content_desc=None):
        """
        Click an element by text, resource-id, or content-desc.
        Returns True if clicked, False if element not found.
        """
        ui_xml = UIAutomator.dump_ui()
        coords = UIAutomator.find_element_bounds(ui_xml, text, resource_id, content_desc)
        if coords:
            x, y = coords
            UIAutomator.run_adb("shell", "input", "tap", str(x), str(y))
            return True
        return False

    @staticmethod
    def has_text(text):
        """Check if UI contains specific text."""
        ui_xml = UIAutomator.dump_ui()
        escaped_text = text.replace("&", "&amp;")
        return f'text="{escaped_text}"' in ui_xml

    @staticmethod
    def screenshot():
        """Capture screenshot and return bytes."""
        result = UIAutomator.run_adb("exec-out", "screencap", "-p")
        if result and result.returncode == 0:
            return result.stdout
        return None


class QRManager:
    """Manages QR code capture, decoding, and refresh logic."""

    MAX_AUTO_REFRESH = 2  # Easy to change

    def __init__(self):
        self.refresh_count = 0
        self.last_qr_data = None

    def detect_page(self):
        """
        Detect current page state.
        Returns: 'qr_valid' | 'qr_expired' | 'login_menu' | 'logged_in' | 'unknown'
        """
        ui_xml = UIAutomator.dump_ui()

        # Check for logged-in indicators
        logged_in_indicators = [
            'text="Chats"', 'text="Weixin"', 'text="Contacts"',
            'text="Discover"', 'text="Me"',
            'text="ÂæÆ‰ø°"', 'text="ÈÄöËÆØÂΩï"', 'text="ÂèëÁé∞"', 'text="Êàë"'
        ]
        if any(ind in ui_xml for ind in logged_in_indicators):
            return 'logged_in'

        # Check for expired QR
        if 'ËøáÊúü' in ui_xml or 'expired' in ui_xml.lower():
            return 'qr_expired'

        # Check for valid QR screen
        if 'Log in by scanning' in ui_xml or 'Êâ´Á†ÅÁôªÂΩï' in ui_xml:
            return 'qr_valid'

        # Check for login menu
        if 'Log in on Phone' in ui_xml or 'ÊâãÊú∫/Âπ≥ÊùøÁôªÂΩï' in ui_xml:
            return 'login_menu'

        return 'unknown'

    def navigate_to_qr(self):
        """Navigate from login menu to QR code page."""
        # Try English text first, then Chinese
        if UIAutomator.click_element(text="Log in on Phone & Tablet"):
            return True
        if UIAutomator.click_element(text="ÊâãÊú∫/Âπ≥ÊùøÁôªÂΩï"):
            return True
        return False

    def refresh_qr(self):
        """Tap to refresh expired QR code."""
        # The expired QR screen has a refresh icon/text
        # Try clicking on the QR code area or refresh text
        ui_xml = UIAutomator.dump_ui()

        # Look for clickable area with expired text
        if UIAutomator.click_element(text="ÁÇπÂáªÈáçÊñ∞Ëé∑Âèñ"):
            return True
        if UIAutomator.click_element(text="Click to refresh"):
            return True

        # Try clicking center of screen where QR would be
        # Find any element with "ËøáÊúü" (expired) and click it
        coords = UIAutomator.find_element_bounds(ui_xml, text="‰∫åÁª¥Á†ÅÂ∑≤ËøáÊúüÔºåÁÇπÂáªÈáçÊñ∞Ëé∑Âèñ")
        if coords:
            UIAutomator.run_adb("shell", "input", "tap", str(coords[0]), str(coords[1]))
            return True

        return False

    def capture_and_decode_qr(self):
        """
        Capture screenshot and decode QR code.
        Returns QR data string or None.
        """
        if not QR_LIBS_AVAILABLE:
            return None

        screenshot = UIAutomator.screenshot()
        if not screenshot:
            return None

        # Convert to OpenCV format
        nparr = np.frombuffer(screenshot, np.uint8)
        img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

        if img is None:
            return None

        # Detect and decode QR (works on any resolution/orientation)
        detector = cv2.QRCodeDetector()
        data, vertices, _ = detector.detectAndDecode(img)

        return data if data else None

    def regenerate_clean_qr(self, data):
        """Generate clean QR code PNG from data."""
        if not QR_LIBS_AVAILABLE:
            return None

        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=2,
        )
        qr.add_data(data)
        qr.make(fit=True)

        qr_img = qr.make_image(fill_color="black", back_color="white")
        buffer = io.BytesIO()
        qr_img.save(buffer, format='PNG')
        return buffer.getvalue()

    def get_qr(self):
        """
        Main method to get QR code.
        Handles navigation, expiration, and refresh logic.

        Returns dict with:
        - status: 'ok' | 'expired' | 'manual_required' | 'logged_in' | 'error'
        - qr: base64 encoded clean QR image (if status == 'ok')
        - refresh_count: number of auto-refreshes done
        - message: human-readable status
        """
        page = self.detect_page()

        # Already logged in
        if page == 'logged_in':
            return {
                'status': 'logged_in',
                'message': 'Already logged in to WeChat'
            }

        # On login menu - navigate to QR
        if page == 'login_menu':
            if not self.navigate_to_qr():
                return {
                    'status': 'error',
                    'message': 'Could not navigate to QR page'
                }
            time.sleep(2)
            page = self.detect_page()

        # QR expired - try refresh
        if page == 'qr_expired':
            if self.refresh_count >= self.MAX_AUTO_REFRESH:
                return {
                    'status': 'manual_required',
                    'refresh_count': self.refresh_count,
                    'message': f'QR expired. Auto-refresh limit ({self.MAX_AUTO_REFRESH}) reached. Click to refresh manually.'
                }

            self.refresh_count += 1
            if self.refresh_qr():
                time.sleep(2)
                # Recursive call to try again
                return self.get_qr()
            else:
                return {
                    'status': 'error',
                    'message': 'Could not refresh QR code'
                }

        # Try to capture and decode QR
        qr_data = self.capture_and_decode_qr()

        if not qr_data:
            # Maybe page changed or decode failed
            page = self.detect_page()
            if page == 'qr_expired':
                # Recurse to handle expiration
                return self.get_qr()
            return {
                'status': 'error',
                'message': 'Could not decode QR code from screen'
            }

        # Success - regenerate clean QR
        self.last_qr_data = qr_data
        self.refresh_count = 0  # Reset on success

        clean_qr = self.regenerate_clean_qr(qr_data)
        if not clean_qr:
            return {
                'status': 'error',
                'message': 'Could not regenerate QR code'
            }

        return {
            'status': 'ok',
            'qr': base64.b64encode(clean_qr).decode(),
            'refresh_count': self.refresh_count,
            'message': 'QR code ready'
        }

    def manual_refresh(self):
        """Handle manual refresh request from user."""
        self.refresh_count = 0  # Reset counter
        if self.refresh_qr():
            time.sleep(2)
            return self.get_qr()
        return {
            'status': 'error',
            'message': 'Could not refresh QR code'
        }

    def check_status(self):
        """Quick status check for polling."""
        page = self.detect_page()
        return {
            'page': page,
            'logged_in': page == 'logged_in',
            'expired': page == 'qr_expired',
            'refresh_count': self.refresh_count,
            'max_auto_refresh': self.MAX_AUTO_REFRESH
        }


# Global QR manager instance
qr_manager = QRManager()


class OnboardingHandler(http.server.BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # Suppress default logging

    def send_json(self, data, status=200):
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def do_GET(self):
        path = urlparse(self.path).path

        if path == "/" or path == "/index.html":
            self.serve_html()
        elif path == "/api/qr":
            self.get_qr()
        elif path == "/api/status":
            self.get_status()
        else:
            self.send_error(404)

    def do_POST(self):
        path = urlparse(self.path).path

        if path == "/api/refresh":
            self.manual_refresh()
        elif path == "/api/upload-migration-qr":
            self.upload_migration_qr()
        else:
            self.send_error(404)

    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

    def get_qr(self):
        """Get QR code with auto-navigation and refresh logic."""
        result = qr_manager.get_qr()
        self.send_json(result)

    def get_status(self):
        """Get current status for polling."""
        result = qr_manager.check_status()
        self.send_json(result)

    def manual_refresh(self):
        """Handle manual refresh button click."""
        result = qr_manager.manual_refresh()
        self.send_json(result)

    def upload_migration_qr(self):
        """Receive uploaded QR code image and set up virtualscene."""
        try:
            content_length = int(self.headers.get('Content-Length', 0))
            body = self.rfile.read(content_length)
            data = json.loads(body)

            image_data = data.get('image', '')
            if ',' in image_data:
                image_data = image_data.split(',')[1]

            image_bytes = base64.b64decode(image_data)

            # Set up virtualscene directory
            avd_path = Path.home() / ".android" / "avd" / f"{AVD_NAME}.avd"
            vs_path = avd_path / "virtualscene"
            vs_path.mkdir(exist_ok=True)

            # Save as poster.png
            poster_path = vs_path / "poster.png"
            with open(poster_path, 'wb') as f:
                f.write(image_bytes)

            # Create posters config
            posters_config = """poster wall
size 2 2
position -0.807 0.320 5.316
rotation 0 -150 0
default poster.png
"""
            with open(vs_path / "posters", 'w') as f:
                f.write(posters_config)

            self.send_json({"success": True, "poster_path": str(poster_path)})
        except Exception as e:
            self.send_json({"error": str(e)}, 500)

    def serve_html(self):
        html = '''<!DOCTYPE html>
<html>
<head>
    <title>WeChat Setup</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #07C160; margin-bottom: 10px; text-align: center; }
        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .qr-container {
            text-align: center;
            padding: 20px;
        }
        .qr-container img {
            max-width: 256px;
            border-radius: 8px;
        }
        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 16px;
        }
        .status.loading { background: #fff7e6; color: #d48806; }
        .status.success { background: #f6ffed; color: #52c41a; }
        .status.error { background: #fff2f0; color: #ff4d4f; }
        .status.warning { background: #fffbe6; color: #faad14; }
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid currentColor;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .btn {
            background: #07C160;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            margin-top: 12px;
        }
        .btn:hover { background: #06ad56; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        .btn-secondary:hover { background: #e0e0e0; }
        .hidden { display: none; }
        .step-indicator {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
        }
        .upload-area {
            border: 2px dashed #d9d9d9;
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        .upload-area:hover { border-color: #07C160; }
        .instructions {
            background: #fafafa;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            font-size: 14px;
        }
        .instructions ol { margin: 0; padding-left: 20px; }
        .instructions li { margin-bottom: 6px; }
    </style>
</head>
<body>
    <h1>WeChat Setup</h1>

    <!-- Step 1: Login -->
    <div id="step-login" class="card">
        <div class="step-indicator">Step 1 of 2: Login</div>

        <div class="qr-container">
            <div id="qr-loading" class="status loading">
                <div class="spinner"></div>
                <span>Loading QR code...</span>
            </div>
            <img id="qr-image" class="hidden" src="" alt="QR Code">
        </div>

        <p style="text-align: center; color: #666; margin: 16px 0;">
            Scan with your phone's WeChat app
        </p>

        <div id="status-box" class="status loading hidden">
            <span id="status-text"></span>
        </div>

        <button id="refresh-btn" class="btn btn-secondary hidden" onclick="manualRefresh()">
            üîÑ Refresh QR Code
        </button>
    </div>

    <!-- Step 2: Migration -->
    <div id="step-migration" class="card hidden">
        <div class="step-indicator">Step 2 of 2: Import Chat History (Optional)</div>

        <div class="instructions">
            <strong>On the tablet (emulator):</strong>
            <ol>
                <li>Go to: Me ‚Üí Settings ‚Üí Chats ‚Üí Migration</li>
                <li>Tap "Migrate to This Device"</li>
                <li>A QR code appears on the tablet</li>
            </ol>
            <br>
            <strong>On your phone:</strong>
            <ol start="4">
                <li>Screenshot the QR from your phone</li>
                <li>Upload it below</li>
            </ol>
        </div>

        <div id="upload-area" class="upload-area" onclick="document.getElementById('file-input').click()">
            üì∑ Click to upload QR screenshot
            <input type="file" id="file-input" accept="image/*" style="display:none" onchange="handleUpload(event)">
        </div>

        <button class="btn btn-secondary" onclick="skipMigration()">
            Skip - I'll import later
        </button>
    </div>

    <!-- Step 3: Done -->
    <div id="step-done" class="card hidden">
        <div style="text-align: center;">
            <div style="font-size: 48px; margin-bottom: 16px;">‚úÖ</div>
            <h2 style="margin: 0 0 8px 0;">Setup Complete!</h2>
            <p style="color: #666;">You can now search your WeChat messages.</p>
            <code style="display: block; background: #f5f5f5; padding: 12px; border-radius: 8px; margin-top: 16px;">
                wechat search "your query"
            </code>
        </div>
    </div>

    <script>
        let pollInterval = null;
        let currentStep = 'login';

        // Initialize
        document.addEventListener('DOMContentLoaded', loadQR);

        async function loadQR() {
            showLoading();
            try {
                const resp = await fetch('/api/qr');
                const data = await resp.json();
                handleQRResponse(data);
            } catch (e) {
                showError('Failed to load QR code: ' + e.message);
            }
        }

        function handleQRResponse(data) {
            const qrImg = document.getElementById('qr-image');
            const loading = document.getElementById('qr-loading');
            const statusBox = document.getElementById('status-box');
            const refreshBtn = document.getElementById('refresh-btn');

            if (data.status === 'ok') {
                // Show QR
                qrImg.src = 'data:image/png;base64,' + data.qr;
                qrImg.classList.remove('hidden');
                loading.classList.add('hidden');
                refreshBtn.classList.add('hidden');
                statusBox.classList.add('hidden');

                // Start polling for login
                startPolling();

            } else if (data.status === 'manual_required') {
                // Show refresh button
                loading.classList.add('hidden');
                refreshBtn.classList.remove('hidden');
                showWarning(data.message);

            } else if (data.status === 'logged_in') {
                // Move to next step
                goToStep('migration');

            } else {
                showError(data.message || 'Unknown error');
            }
        }

        function showLoading() {
            document.getElementById('qr-loading').classList.remove('hidden');
            document.getElementById('qr-image').classList.add('hidden');
        }

        function showError(msg) {
            const statusBox = document.getElementById('status-box');
            statusBox.className = 'status error';
            document.getElementById('status-text').textContent = msg;
            statusBox.classList.remove('hidden');
        }

        function showWarning(msg) {
            const statusBox = document.getElementById('status-box');
            statusBox.className = 'status warning';
            document.getElementById('status-text').textContent = msg;
            statusBox.classList.remove('hidden');
        }

        async function manualRefresh() {
            const btn = document.getElementById('refresh-btn');
            btn.disabled = true;
            btn.textContent = 'Refreshing...';

            try {
                const resp = await fetch('/api/refresh', { method: 'POST' });
                const data = await resp.json();
                handleQRResponse(data);
            } catch (e) {
                showError('Refresh failed: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîÑ Refresh QR Code';
            }
        }

        function startPolling() {
            if (pollInterval) clearInterval(pollInterval);
            pollInterval = setInterval(checkStatus, 3000);
        }

        async function checkStatus() {
            try {
                const resp = await fetch('/api/status');
                const data = await resp.json();

                if (data.logged_in) {
                    clearInterval(pollInterval);
                    goToStep('migration');
                } else if (data.expired) {
                    // QR expired, try to refresh
                    clearInterval(pollInterval);
                    loadQR();
                }
            } catch (e) {
                console.error('Status check failed:', e);
            }
        }

        function goToStep(step) {
            document.getElementById('step-login').classList.add('hidden');
            document.getElementById('step-migration').classList.add('hidden');
            document.getElementById('step-done').classList.add('hidden');
            document.getElementById('step-' + step).classList.remove('hidden');
            currentStep = step;

            if (step !== 'login' && pollInterval) {
                clearInterval(pollInterval);
            }
        }

        function skipMigration() {
            goToStep('done');
        }

        async function handleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const uploadArea = document.getElementById('upload-area');
                uploadArea.innerHTML = '‚è≥ Uploading...';

                try {
                    const resp = await fetch('/api/upload-migration-qr', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ image: e.target.result })
                    });
                    const data = await resp.json();

                    if (data.success) {
                        uploadArea.innerHTML = '‚úÖ Uploaded! Follow emulator instructions.';
                        setTimeout(() => goToStep('done'), 3000);
                    } else {
                        uploadArea.innerHTML = '‚ùå Upload failed: ' + (data.error || 'Unknown');
                    }
                } catch (err) {
                    uploadArea.innerHTML = '‚ùå Upload failed: ' + err.message;
                }
            };
            reader.readAsDataURL(file);
        }
    </script>
</body>
</html>'''
        self.send_response(200)
        self.send_header("Content-Type", "text/html")
        self.end_headers()
        self.wfile.write(html.encode())


def main():
    print(f"Starting onboarding server on http://localhost:{PORT}")
    print("Open this URL in your browser to begin setup.")
    print(f"Max auto-refresh: {QRManager.MAX_AUTO_REFRESH}")

    server = http.server.HTTPServer(("localhost", PORT), OnboardingHandler)

    # Open browser
    import webbrowser
    webbrowser.open(f"http://localhost:{PORT}")

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nServer stopped.")


if __name__ == "__main__":
    main()
