#!/bin/bash
# diagnose - Run language-specific diagnostics on files
# Silent on success, outputs errors only (designed for AI agents)
set -eo pipefail

VERBOSE=false
TARGET=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose) VERBOSE=true; shift ;;
        *) TARGET="$1"; shift ;;
    esac
done

# Detect language from shebang
detect_from_shebang() {
    local shebang
    shebang=$(head -1 "$1" 2>/dev/null)
    case "$shebang" in
        *bash*|*"/bin/sh"*) echo "shell" ;;
        *python*) echo "python" ;;
        *node*) echo "javascript" ;;
        *) echo "" ;;
    esac
}

# Detect language
detect_language() {
    local target="$1"
    if [ -f "$target" ]; then
        case "$target" in
            *.ts|*.tsx) echo "typescript" ;;
            *.js|*.jsx) echo "javascript" ;;
            *.py) echo "python" ;;
            *.go) echo "go" ;;
            *.rs) echo "rust" ;;
            *.sh|*.bash) echo "shell" ;;
            *) detect_from_shebang "$target" || echo "unknown" ;;
        esac
    elif [ -d "$target" ]; then
        if [ -f "$target/tsconfig.json" ]; then echo "typescript"
        elif [ -f "$target/package.json" ]; then echo "javascript"
        elif [ -f "$target/pyproject.toml" ]; then echo "python"
        elif [ -f "$target/go.mod" ]; then echo "go"
        elif [ -f "$target/Cargo.toml" ]; then echo "rust"
        else echo "unknown"
        fi
    fi
}

# Find project root
find_project_root() {
    local dir="$1"
    [ -f "$dir" ] && dir=$(dirname "$dir")
    while [ "$dir" != "/" ]; do
        [ -f "$dir/tsconfig.json" ] || [ -f "$dir/package.json" ] || \
        [ -f "$dir/pyproject.toml" ] || [ -f "$dir/go.mod" ] || \
        [ -f "$dir/Cargo.toml" ] && { echo "$dir"; return; }
        dir=$(dirname "$dir")
    done
    pwd
}

# Run diagnostics on a single file
run_diagnostics() {
    local target="$1"
    local lang="$2"
    local root
    root=$(find_project_root "$target")

    case "$lang" in
        typescript)
            command -v tsc &>/dev/null && { cd "$root" && tsc --noEmit 2>&1; return; }
            command -v npx &>/dev/null && { cd "$root" && npx tsc --noEmit 2>&1; return; }
            echo "tsc not found"; return 1
            ;;
        javascript)
            command -v eslint &>/dev/null && { eslint "$target" 2>&1; return; }
            command -v npx &>/dev/null && { npx eslint "$target" 2>&1; return; }
            ;;
        python)
            local out=""
            command -v ruff &>/dev/null && out=$(ruff check "$target" 2>&1) || true
            command -v pyright &>/dev/null && out="$out"$'\n'$(pyright "$target" 2>&1) || true
            [ -n "$out" ] && echo "$out"
            ;;
        go)
            command -v go &>/dev/null || { echo "go not found"; return 1; }
            go vet "$target" 2>&1 || true
            go build -o /dev/null "$target" 2>&1
            ;;
        rust)
            command -v cargo &>/dev/null || { echo "cargo not found"; return 1; }
            cd "$root" && cargo check --message-format short 2>&1
            ;;
        shell)
            command -v shellcheck &>/dev/null || return 0
            shellcheck "$target" 2>&1
            ;;
        *)
            return 0
            ;;
    esac
}

# Diagnose a single file
diagnose_file() {
    local file="$1"

    if [ ! -e "$file" ]; then
        echo "Error: '$file' not found"
        return 1
    fi

    local lang
    lang=$(detect_language "$file")
    local output
    output=$(run_diagnostics "$file" "$lang" 2>&1) || local exit_code=$?
    exit_code=${exit_code:-0}

    if [ "$exit_code" -ne 0 ]; then
        echo "Errors in $file:"
        echo "$output"
        return 1
    elif $VERBOSE; then
        echo "No errors in $file"
    fi
    return 0
}

# Diagnose uncommitted files in worktree
diagnose_worktree() {
    if ! git rev-parse --git-dir &>/dev/null; then
        echo "Not in a git repository"
        return 1
    fi

    local repo_root
    repo_root=$(git rev-parse --show-toplevel)

    # Get uncommitted files (modified + staged + untracked) as absolute paths
    local files
    files=$(git status --porcelain | awk -v root="$repo_root" '{print root "/" $NF}')

    if [ -z "$files" ]; then
        $VERBOSE && echo "No uncommitted files"
        echo ""
        echo "diagnose <file|directory> [--verbose]"
        return 0
    fi

    local has_errors=false
    local checked=0

    while IFS= read -r file; do
        # Skip deleted files and non-existent files
        [ ! -f "$file" ] && continue

        # Skip unsupported file types
        local lang
        lang=$(detect_language "$file")
        [ "$lang" = "unknown" ] && continue

        ((checked++)) || true
        diagnose_file "$file" || has_errors=true
    done <<< "$files"

    $VERBOSE && echo "Checked $checked files"
    echo ""
    echo "diagnose <file|directory> [--verbose]"

    $has_errors && return 1
    return 0
}

# Main
if [ -z "$TARGET" ]; then
    # Default: check uncommitted files in worktree
    diagnose_worktree
else
    diagnose_file "$TARGET"
fi
